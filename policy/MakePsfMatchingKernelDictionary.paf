#<?cfg paf dictionary ?>
#
# Dictionary for makePsfMatchingKernel
#
definitions: {

    detThresholdType: {
        type: string
        description: "type of detection threshold"
        maxOccurs: 1
        default: "stdev"
        allowed: {
           value:        "value"
           description:  "use counts as the detection threshold type"
        }
        allowed: {
           value:        "stdev"
           description:  "use standard deviation as the detection threshold type"
        }
        allowed: {
           value:        "variance"
           description:  "use variance as the detection threshold type"
        }
    }

     detThreshold: {
        type: double
        description: "value of footprint detection threshold"
        maxOccurs: 1
        default: 10.
    }

    detOnTemplate: {
        type: bool
        description: "If true run detection on the template (imageToConvolve);
            if false run detection on the science image (imageToNotConvolve)"
        maxOccurs: 1
        default: true
    }
    
    detBadMaskPlanes: {
        type: string
        description: "Mask planes that lead to an invalid detection
            Options: EDGE SAT BAD CR INTRP
            E.g. : EDGE SAT BAD allows CR-masked and interpolated pixels"
       default: "EDGE" "SAT" "BAD"
    }


    fpNpixMin: {
        type: int
        description: "minimum number of pixels in an acceptable Footprint"
        maxOccurs: 1
        default: 5
    }

    fpNpixMax: {
        type: int
        description: "maximum number of pixels in an acceptable Footprint;
            too big and the subsequent convolutions become unwieldy"
        maxOccurs: 1
        default: 500
    }

    fpGrowFwhmScaling: {
        type: double
        description: "grow the footprint based on the Psf Fwhm;
            should be larger than kernelRadiusFwhmScaling"
        maxOccurs: 1
        default: 10.
    }

    fpGrowMin: {
        type: int
        description: "minimum amount to grow the footprint"
        maxOccurs: 1
        default: 20
    }

    fpGrowMax: {
        type: int
        description: "maximum amount to grow the footprint"
        maxOccurs: 1
        default: 40
    }

    fpGrowPix: {
        type: int
        description: "Grow each raw detection footprint by this many pixels.
            The smaller the faster; however the kernel sum does not converge if the stamp is too small;
            and the kernel is not constrained at all if the stamp is the size of the kernel.
            Rule of thumb is at least 1.5 times the kernel size.
   
            The grown stamp is ~2*fpGrowPix pixels larger in each dimension."
        maxOccurs: 1
        default: 30
    }


    kernelBasisSet: {
        type: string
        description: "Type of basis set for PSF matching kernel."
        maxOccurs: 1
        default: "delta-function"
        allowed: {
            value:        "alard-lupton"
            description:  "Alard-Lupton sum-of-gaussians basis set
            * The first term has no spatial variation
            * The kernel sum is conserved
            * You may want to turn off 'usePcaForSpatialKernel'
            * The half-width of the kernel is kernelCols//2, kernelRows//2"
        }
        allowed: {
            value:        "delta-function"
            description:  "delta-function kernel basis set
            * You may enable the option useRegularization
            * You should seriously consider usePcaForSpatialKernel, which will also
              enable kernel sum conservation for the delta function kernels.
            * There will be kernelRows x kernelCols basis kernels; one per kernel pixel"
        }
    }

    kernelCols: {
        type: int
        description: "number of columns in the convolution kernel"
        maxOccurs: 1
        default: 19
    }
    kernelRows: {
        type: int
        description: "number of rows in the convolution kernel"
        maxOccurs: 1
        default: 19
    }

    kernelRadiusFwhmScaling: {
        type: double
        description: "How much to scale the kernel size based on the Psf Fwhm;
        should be smaller than fpGrowFwhmScaling."
        maxOccurs: 1
        default: 2.5
    }

    kernelRadiusMin: {
        type: int
        description: "Minimum kernel radius; kernelRows, kernelCols = 2 * kernelRadius + 1"
        maxOccurs: 1
        default: 7
    }

    kernelRadiusMax: {
        type: int
        description: "maximum kernel radius; kernelRows, kernelCols = 2 * kernelRadius + 1"
        maxOccurs: 1
        default: 15
    }

    ######
    #
    # Alard-Lupton Parameters
    #
    alardNGauss: {
        type: int
        description: "number of gaussians in alard-lupton basis"
        maxOccurs: 1
        default: 3
    }
    alardDegGauss: {
        type: int
        description: "degree of spatial modification of gaussians in alard-lupton basis"
        maxOccurs: 3
        default: 4 3 2
    }
    alardSigGauss: {
        type: double
        description: "sigma of gaussians in alard-lupton basis (note: FWHM = 2.35 sigma)"
        maxOccurs: 3
        default: 0.7 1.5 3.0
    }
    alardSigFwhmScaling: {
        type: double
        description: "scaling of the alard-lupton gaussian sigmas"
        maxOccurs: 3
        default: 0.50 1.00 2.00
    }

    ######
    #
    # Regularized Delta Function Parameters
    #
    # order      : 
    # boundary   : 
    # difference : 
    # scaling    : 
    #
    useRegularization: {
        type: bool
        description: "Use regularization to smooth the delta function kernels?"
        maxOccurs: 1
        default: true
    }
    
    regularizationType: {
        type: string
        description: "Type of regularization."
        maxOccurs: 1
        default: "centralDifference"
        allowed: {
            value:        "centralDifference"
            description:  "Penalize second derivative using 2-D stencil"
        }
        allowed: {
            value:        "forwardDifference"
            description:  "Penalize first, second, third or combination of derivatives"
        }
    }

    centralRegularizationStencil: {
        type: int
        description: "5 or 9 point stencil (for centralDifference only)"
        default: 9
        allowed: {
            value:        5
        }
        allowed: {
            value:        9
        }
    }

    forwardRegularizationOrders: {
        type: int
        description: "Array showing which order derivatives to penalize (for forwardDifference only)"
        default: 1 2
    }

    regularizationBorderPenalty: {
        type: double
        description: "Penalty for value of kernel along its border"
        maxOccurs: 1
        default: 3.0
    }

    regularizationScaling: {
        type: double
        description: "Fraction of the default lambda strength (N.R. 18.5.8) to use. 
                      somewhere around 1e-4 to 1e-5 seems to work.
                      some kernels need high freq power"
        maxOccurs: 1
        default: 1e-4
    }

    lambdaType: {
        type: string
        maxOccurs: 1
        default: "absolute"
        allowed: {
            value:        "absolute"
            description:  "Use lambdaValue as the value of lambda"
        }
        allowed: {
            value:        "relative"
            description:  "lambdaValue as a fraction of the default lambda strength (N.R. 18.5.8)"
        }
        allowed: {
            value:        "minimizeBiasedRisk"
            description:  "Minimize biased risk estimate"
        }
        allowed: {
            value:        "minimizeUnbiasedRisk"
            description:  "Minimize unbiased risk estimate"
        }
        allowed: {
            value:        "minimizeGcv"
            description:  "Minimize generalized cross-validation statistic; scan lambda"
        }
    }
    
    lambdaValue: {
        type: double
        maxOccurs: 1
        default: 1.0
    }

    lambdaStepType: {
        type: string
        maxOccurs: 1
        default: "log"
        allowed: {
            value: "log"
        }
        allowed: {
            value: "linear"
        }
    }
    
    lambdaLinMin: {
        type: double
        maxOccurs: 1
        default: 1.0
    }
    
    lambdaLinMax: {
        type: double
        maxOccurs: 1
        default: 500.0
    }
    
    lambdaLinStep: {
        type: double
        maxOccurs: 1
        default: 10.0
    }
    
    lambdaLogMin: {
        type: double
        maxOccurs: 1
        default: -3.0
    }
    
    lambdaLogMax: {
        type: double
        maxOccurs: 1
        default: +2.0
    }
    
    lambdaLogStep: {
        type: double
        maxOccurs: 1
        default: 0.1
    }

    ####################################
    # KERNEL QUALITY CONTROL
    #
    maxKsumSigma: {
        type: double
        description: "Maximum allowed sigma for outliers from kernel sum distribution"
        maxOccurs: 1
        default: 3.0
    }

    candidateResidualMeanMax: {
        type: double
        description: "Rejects objects with bad difference image quality
            
            This is used as a proxy for the quality of the kernel.  We look at
            both the mean value of the residuals in the difference image
            (normalized by the noise; expectation value is 0.0) as well as the
            width of the distribution (expectation value 1.0)
            
            Maximum diffim average of (residual/noise) for an acceptable Kernel"
        maxOccurs: 1
        default: 0.25
    }
    candidateResidualStdMax: {
        type: double
        description: "Maximum diffim standard deviation of (residual/noise) for an acceptable Kernel"
        maxOccurs: 1
        default: 1.25
    }

    ######
    # 
    # What types of sigma clipping to enable
    #
    # If you want sigma clipping at each step along the way, it should be:
    #   singleKernelClipping:  true
    #   kernelSumClipping:     true
    #   spatialKernelClipping: true
    #
    # If you only care about the final spatial kernel quality it should be:
    #   singleKernelClipping:  false
    #   kernelSumClipping:     false
    #   spatialKernelClipping: true
    #
    #
    singleKernelClipping: {
        type: bool
        description: "Do sigma clipping on each raw kernel candidate?"
        maxOccurs: 1
        default: true
    }
    kernelSumClipping: {
        type: bool
        description: "Do sigma clipping on the ensemble of kernel sums?"
        maxOccurs: 1
        default: true
    }
    spatialKernelClipping: {
        type: bool
        description: "Do sigma clipping on the spatial model?"
        maxOccurs: 1
        default: true
    }

    candidateCoreRadius: {
        type: int
        description: "Radius for calculation of stats in 'core' of KernelCandidate diffim.
            Total number of pixels used will be (2*radius)**2. 
            This is used both for 'core' diffim quality as well as ranking of
            KernelCandidates by their total flux in this core"
        maxOccurs: 1
        default: 3
    }

    checkConditionNumber: {
        type: bool
        description: "Test for maximum condition number when inverting a kernel matrix?
            Anything above the value is not used and the candidate is set as BAD.        
            Also used to truncate inverse matrix in estimateBiasedRisk."
        maxOccurs: 1
        default: false
    }

    conditionNumberType: {
        type: bool
        description: 
        allowed: {
            value: "SVD"
            description: "Use singular values"
        }
        allowed: {
            value: "EIGENVALUE"
            description: "Use eigen values"
        }
    }
    
    maxConditionNumber: {
        type: double
        description: "Maximum condition number for a well conditioned matrix.
            Suggested value:
            * 5.0e6 for 'delta-function' basis
            * 5.0e7 for 'alard-lupton' basis"
        maxOccurs: 1
        default: 5.0e7
    }


    iterateSingleKernel: {
        type: bool
        description: "Remake single kernel using better variance estimate after first pass?
            Primarily useful when convolving a single-depth image, otherwise not necessary."
        maxOccurs: 1
        default: false
    }

    constantVarianceWeighting: {
        type: bool
        description: "Use constant variance weighting in single kernel fitting?
            In some cases this is better for bright star residuals."
        maxOccurs: 1
        default: false
    }

    calculateKernelUncertainty: {
        type: bool
        description: "Calculate kernel and background uncertainties for each kernel candidate?
            This comes from the inverse of the covariance matrix.
            Warning: regularization can cause problems for this step."
        maxOccurs: 1
        default: false
    }

    psfMatchToGaussian: {
        type: bool
        description: "Psf match to an idealized Gaussian instead of another image?
            Requires that the user locate the Footprints of isolated stars"
        maxOccurs: 1
        default: false
    }
    psfMatchToGaussianSigma1: {
        type: double
        description: "width of first gaussian in double-gaussian Psf model"
        maxOccurs: 1
        default: 3.0
    }
    psfMatchToGaussianFlux1: {
        type: double
        description: "fraction of flux in first gaussian in double-gaussian Psf model"
        maxOccurs: 1
        default: 0.9
    }
    psfMatchToGaussianSigma2: {
        type: double
        description: "width of second gaussian in double-gaussian Psf model"
        maxOccurs: 1
        default: 5.0
    }
    psfMatchToGaussianFlux2: {
        type: double
        description: "fraction of flux in second gaussian in double-gaussian Psf model"
        maxOccurs: 1
        default: 0.1
    }


    spatialKernelOrder: {
        type: int
        description: "Spatial order of convolution kernel variation.
            If you are using a large image, spatialKernelOrder=0, and a constant
            kernel is a bad approximation, you probably want to use the
            following configuration for the sigma clipping above:

            * singleKernelClipping:  true
            * kernelSumClipping:     true
            * spatialKernelClipping: false"
        maxOccurs: 1
        default: 1
    }
    spatialBgOrder: {
        type: int
        description: "Spatial order of differential background variation."
        maxOccurs: 1
        default: 0
    }

    sizeCellX: {
        type: int
        description: "size (rows) in pixels of each SpatialCell for spatial modeling"
        maxOccurs: 1
        default: 256
    }
    sizeCellY: {
        type: int
        description: "size (columns) in pixels of each SpatialCell for spatial modeling"
        maxOccurs: 1
        default: 256
    }
    nStarPerCell: {
        type: int
        description: "number of candidates in each SpatialCell to use in the spatial fitting"
        maxOccurs: 1
        default: 1
    }

    maxSpatialIterations: {
        type: int
        description: "maximum number of iterations for rejecting bad footprints in the spatial fitting"
        maxOccurs: 1
        default: 5
    }

    usePcaForSpatialKernel: {
        type: bool
        description: "Use Pca to reduce the dimensionality of the kernel basis sets.
            This is particularly useful for delta-function kernels,
            but may also work with Alard-Lupton kernels.
            
            Functionally, after all Cells have their raw kernels determined, we run a PCA on these Kernels
            re-fit the Cells using the eigenKernels and the fit those for spatial variation using the same
            technique as for the non-PCA delta-function and Alard-Lupton kernels.
            
            If this option is used, the first term (mean kernel) will have no
            spatial variation and the kernel sum will be conserved."
        maxOccurs: 1
        default: true
    }

    subtractMeanForPca: {
        type: bool
        description: "Subtract off the mean feature before doing the Pca?"
        maxOccurs: 1
        default: true
    }

    numPrincipalComponents: {
        type: int
        description: "Number of principal components to use for Pca basis, not counting the mean kernel.
            Thus you will have numPrincipalComponents + 1 basis functions for the decomposition."
        maxOccurs: 1
        default: 4
    }

    fracEigenVal: {
        type: double
        description: "At what fraction of the eigenvalues do you cut off the expansion?
            Warning: not yet implemented"
        maxOccurs: 1
        default: 0.95
    }

    fitForBackground: {
        type: bool
        description: "Include terms (including kernel cross terms) for background"
        maxOccurs: 1
        default: true
    }

    useAfwBackground: {
        type: bool
        description: "Use afw background subtraction instead of ip_diffim."
        maxOccurs: 1
        default: false
    }

    backgroundPolicy: {
        type: policy
        description: "policy in case diffim needs to do background subtraction"
        dictionary: {
            definitions: {
                algorithm: {
                    type: string
                    description: "how to interpolate the background values"
                    maxOccurs: 1
                    default: "NATURAL_SPLINE" 
                    allowed: {
                        value: "CONSTANT"
                    }
                    allowed: {
                        value: "LINEAR"
                    }
                    allowed: {
                        value: "NATURAL_SPLINE"
                    }
                    allowed: {
                        value: "CUBIC_SPLINE"
                    }
                    allowed: {
                        value: "CUBIC_SPLINE_PERIODIC"
                    }
                    allowed: {
                        value: "AKIMA_SPLINE"
                    }
                    allowed: {
                        value: "AKIMA_SPLINE_PERIODIC"
                    }
                }

                binsize: {
                    type: int
                    description: "how large regions should be used for each background point"
                    maxOccurs: 1
                    default: 512
                }

                undersample: {
                    type: string
                    description: "what to do if there are not enough regions for the interpolation"
                    maxOccurs: 1
                    default: "REDUCE_INTERP_ORDER"
                    allowed: {
                        value: "THROW_EXCEPTION"
                    }
                    allowed: {
                        value: "REDUCE_INTERP_ORDER"
                    }
                    allowed: {
                        value: "INCREASE_NXNYSAMPLE"
                    }
                }
            }
        }
        maxOccurs: 1
    }
}
